# A collection of sorting algorithms implemented in C++

## Bubble Sort
A slow sorting algorithm for the simplest data sets

| Case  | Performance |
| :---: | :---: |
| Worst case performance   | O(n^2)  |
| Best case performance  | O(n)  |
| Average case performance  | O(n^2)  |
| Auxiliary Space           | O(1)  |

![bubble-sort-gif-9](https://user-images.githubusercontent.com/36489953/42171410-83532a64-7e19-11e8-95a1-b2dd3aaedc43.gif)


## Insertion Sort
Insertion Sort is often used when the data set is nearly sorted (it takes minimum time (Order of n))  
Insertion sort takes maximum time to sort if elements are sorted in reverse order.

| Case  | Performance |
| :---: | :---: |
| Worst case performance   | O(n^2)  |
| Best case performance  | O(n)  |
| Average case performance  | O(n^2)  |
| Auxiliary Space           | O(1)  |

![1_kra0ofxedgi8hvhjffci4w](https://user-images.githubusercontent.com/36489953/42171484-b508016a-7e19-11e8-8d47-3b95d788d579.gif)

## Selection Sort

Selection sort is noted for its simplicity, and it has performance advantages over more complicated algorithms in certain situations, particularly where auxiliary memory is limited

| Case  | Performance |
| :---: | :---: |
| Worst case performance   | O(n^2)  |
| Best case performance  | O(n^2)  |
| Average case performance  | O(n^2)  |
| Auxiliary Space           | O(1)  |

![selectionsort](https://user-images.githubusercontent.com/36489953/42171344-5554d9d2-7e19-11e8-8537-7811ebbbd1b6.gif)


## Merge Sort

A single most important advantage of merge sort over quick sort 
is its stability: the elements compared equal retain their original order.

| Case  | Performance |
| :---: | :---: |
| Worst case performance   | O(n log n)  |
| Best case performance  | O(n log n)  |
| Average case performance  | O(n log n)  |
| Auxiliary Space           | O(n)  |  


![merge-sort-example-300px](https://user-images.githubusercontent.com/36489953/42171944-ed5814c8-7e1a-11e8-9d30-10ae8047bb17.gif)

## Quick sort

Quicksort is more effective for datasets that fit in memory.  
For large datasets, it's better to use mergesort.

| Case  | Performance |
| :---: | :---: |
| Worst case performance   | O(n^2)  |
| Best case performance  | O(n log n)  |
| Average case performance  | O(n log n)  |
| Auxiliary Space           | O(log(n)) |

![quick_sort_partition_animation](https://user-images.githubusercontent.com/36489953/42172331-f759ecd4-7e1b-11e8-906e-90d04a83e5a5.gif)
